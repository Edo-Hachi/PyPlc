# GEMINI提案: PLC回路の接続情報と通電解析アーキテクチャ

## 概要

`Ver3_Definition.md`の「明示的配線システム」と「自己保持回路の動作」という目標を達成するための、デバイス接続情報の保持方法と、通電解析（結線）アルゴリズムに関する設計プラン。

## 1. データ構造：デバイス自身が接続情報を持つ

PLC回路を一種の「グラフ」として捉え、各デバイス（ノード）が隣接デバイス（エッジ）への接続情報を持つ構造を採用する。

### `PLCDevice`クラスの拡張案

`core/device_base.py`で定義する`PLCDevice`クラスに、四方の接続情報を保持するフィールドを追加する。

```python
# core/device_base.py の拡張イメージ

from dataclasses import dataclass, field
from typing import Tuple, Dict, Optional
from config import DeviceType

@dataclass
class PLCDevice:
    """PLCデバイスの基本データ構造（接続情報を含む）""" 
    device_type: DeviceType
    position: Tuple[int, int]  # グリッド座標 (row, col)
    address: str
    state: bool = False
    
    # --- 接続情報 ---
    # key: "up", "down", "left", "right"
    # value: 接続先デバイスのユニークID（例: "row_col"文字列やオブジェクト参照）
    connections: Dict[str, Optional[str]] = field(default_factory=dict)
    
    # --- 回路解析用 ---
    is_energized: bool = False # このデバイスが通電しているか
```

### このデータ構造の利点

1.  **明示的な接続:** 各デバイスが上下左右のどのデバイスに接続されているかを明確に保持する。これにより、「暗黙の配線」問題を完全に解決する。
2.  **柔軟性と統一性:** `LINK_UP`/`LINK_DOWN`による垂直接続も、`LINK_SIDE`による水平接続も、すべてこの`connections`辞書で統一的に表現できる。
3.  **解析の容易性:** あるデバイスから`connections`をたどることで、回路網のトレースが容易になる。これは次の結線アルゴ-リズムの基礎となる。

## 2. 結線アルゴリズム：回路解析エンジンによる走査

デバイスの配置・削除が行われるたびに、`GridSystem`がそのデバイスと周囲のデバイスの`connections`情報を更新する。これにより、データとして常に最新の回路網が維持される。

この回路網の「通電状態」を計算するのが、**回路解析エンジン** (`core/circuit_analyzer.py`) の役割となる。これはPLCの「スキャン」動作を模倣する。

### 通電ロジックの計算手順 (`solve_logic`)

1.  **リセット:**
    *   まず、バスバー以外のすべてのデバイスの`is_energized`フラグを`False`にリセットする。

2.  **走査の開始点:**
    *   グリッドの左端にあるすべての`L_SIDE`（電源バス）を探す。これらが電力の供給源であり、常に`is_energized = True`となる。ここが走査のスタート地点になる。

3.  **深さ優先探索 (DFS) による通電トレース:**
    *   各`L_SIDE`から、接続されている右隣のデバイスに向かって、再帰的に通電をトレースする。
    *   **トレース関数 `trace_power(device)` の処理概要:**
        a.  現在の`device`を「訪問済み」としてマークする（自己保持回路のようなループでの無限再帰を防ぐため）。
        b.  現在の`device`の`is_energized`を`True`にする。
        c.  現在の`device`のロジックを評価し、通電が継続するか判断する。
            *   **開いた接点** (`CONTACT_A`で`state`が`False`など) に到達した場合、そこで通電はストップする。
            *   **コイル** (`COIL`) に到達した場合、そのコイルの`state`を`True`に更新する。
            *   **配線や閉じた接点**の場合、通電は継続する。
        d.  通電が継続する場合、`device.connections`をたどり、まだ「訪問済み」でない隣接デバイスに対して、再帰的に`trace_power()`を呼び出す。

4.  **結果の反映:**
    *   このトレース処理が完了すると、`L_SIDE`から電気的に到達可能なすべてのデバイスの`is_energized`フラグが`True`になる。
    *   描画処理では、この`is_energized`フラグを参照して、通電している配線やデバイスの色を変化させる。

## 3. 補足：PLCの基本原則（最重要）

### アドレスが唯一の真実
PLCの世界では、デバイスの**「アドレス」**（`X001`, `Y001`, `M1`など）が、そのデバイスの状態を管理する**唯一のID**です。グリッド上のどこに配置されていようと、`X001`というアドレスを持つデバイスは、プログラム全体で**ただ一つの実体**として扱われます。

### コイルと接点の役割分担

この原則に基づき、2つの基本要素は明確に役割が分かれています。

*   **コイル (`-( )-)` の役割：状態を「書き込む」**
    *   コイルは、その行の論理演算の**「結果」**として、特定のアドレスの状態をON/OFFに**書き込む**ためのデバイスです。
    *   **ルール:** プログラム全体で、同じアドレスを持つ**標準コイルは1つしか配置できません**（二重コイルエラー）。

*   **接点 (`-| |-, -|/|-)` の役割：状態を「読み出す」**
    *   接点は、特定のアドレスの現在の状態を**「読み出し」**、その行の**「入力条件」**として使用するためのデバイスです。
    *   **ルール:** 同じアドレスの接点は、プログラム内に**何個でも配置できます**。

この「書き込み（コイル）」と「読み出し（接点）」の役割分担を理解することが、PLCシミュレーターを正しく実装する上での鍵となります。

## 4. 補足：PLCの論理スキャンと垂直リンクの概念

### PLCの動作原理

PLCは物理的な配線をそのままシミュレートするのではなく、ラダー図を**上から下へ、左から右へ**と順番に「解読」していくプログラムである。電力の「逆流」という概念はなく、「下の行の条件が成立したかを参照し、成立していれば上の行の分岐をONにする」と解釈するのが、PLCの動作に最も近い。

### 垂直リンクの命名と役割

この動作原理に基づき、垂直リンクの役割を明確にするため、以下の命名規則を採用する。

*   **`LINK_TO_UP`**: 下の行に配置される。**役割:** 上の行へ論理を送る**分岐点**となる。
    *   旧称: `LINK_DOWN`

*   **`LINK_FROM_DOWN`**: 上の行に配置される。**役割:** 下の行からの論理を受け取る**合流点**となる。
    *   旧称: `LINK_UP`

この命名により、電力（論理）の流れがコード上で直感的になり、解析アルゴリズムの実装が容易になる。

## 結論

このアーキテクチャにより、複雑な自己保持回路や並列回路であっても、その接続状態と通電状態を正確にシミュレートすることが可能になる。

### 2025-08-02 (core/device_palette.py レビュー)

#### 🚧 気になる点

1.  **マウス入力処理の欠如:**
    *   `DevicePalette` クラスの docstring には「マウス選択対応」と記載されているが、`update_input` メソッド内では `_handle_keyboard_input()` しか呼び出されておらず、マウス入力に関するロジックが実装されていない。これはドキュメントと実際のコードの不一致。
    *   `CLAUDE.md` の「入力処理設計」にも「マウス直接選択（行切り替え不要）」とあるため、この機能は実装されるべきもの。

2.  **モジュール構成の計画との不一致:**
    *   `CLAUDE.md` の「Ver3デバイスパレットシステム設計完了」セクションでは、モジュール構成として `core/device_palette.py` (状態管理・ロジック)、`core/palette_renderer.py` (描画専用)、`core/palette_input.py` (入力処理専用) との役割分担が計画されている。
    *   しかし、現在の `core/device_palette.py` は `update_input` (入力処理) と `draw` (描画処理) の両方を直接含んでおり、計画されているモジュール分割がまだ行われていない。
    *   このままでは、将来的に `palette_renderer.py` や `palette_input.py` を作成する際に、現在の `DevicePalette` クラスからこれらのロジックを切り出すリファクタリングが必要になる。