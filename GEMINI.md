# GEMINI提案: PLC回路の接続情報と通電解析アーキテクチャ

## 概要

`Ver3_Definition.md`の「明示的配線システム」と「自己保持回路の動作」という目標を達成するための、デバイス接続情報の保持方法と、通電解析（結線）アルゴリズムに関する設計プラン。

## 1. データ構造：デバイス自身が接続情報を持つ

PLC回路を一種の「グラフ」として捉え、各デバイス（ノード）が隣接デバイス（エッジ）への接続情報を持つ構造を採用する。

### `PLCDevice`クラスの拡張案

`core/device_base.py`で定義する`PLCDevice`クラスに、四方の接続情報を保持するフィールドを追加する。

```python
# core/device_base.py の拡張イメージ

from dataclasses import dataclass, field
from typing import Tuple, Dict, Optional
from config import DeviceType

@dataclass
class PLCDevice:
    """PLCデバイスの基本データ構造（接続情報を含む）""" 
    device_type: DeviceType
    position: Tuple[int, int]  # グリッド座標 (row, col)
    address: str
    state: bool = False
    
    # --- 接続情報 ---
    # key: "up", "down", "left", "right"
    # value: 接続先デバイスのユニークID（例: "row_col"文字列やオブジェクト参照）
    connections: Dict[str, Optional[str]] = field(default_factory=dict)
    
    # --- 回路解析用 ---
    is_energized: bool = False # このデバイスが通電しているか
```

### このデータ構造の利点

1.  **明示的な接続:** 各デバイスが上下左右のどのデバイスに接続されているかを明確に保持する。これにより、「暗黙の配線」問題を完全に解決する。
2.  **柔軟性と統一性:** `LINK_UP`/`LINK_DOWN`による垂直接続も、`LINK_HORZ`による水平接続も、すべてこの`connections`辞書で統一的に表現できる。
3.  **解析の容易性:** あるデバイスから`connections`をたどることで、回路網のトレースが容易になる。これは次の結線アルゴ-リズムの基礎となる。

## 2. 結線アルゴリズム：回路解析エンジンによる走査

デバイスの配置・削除が行われるたびに、`GridSystem`がそのデバイスと周囲のデバイスの`connections`情報を更新する。これにより、データとして常に最新の回路網が維持される。

この回路網の「通電状態」を計算するのが、**回路解析エンジン** (`core/circuit_analyzer.py`) の役割となる。これはPLCの「スキャン」動作を模倣する。

### 通電ロジックの計算手順 (`solve_logic`)

1.  **リセット:**
    *   まず、バスバー以外のすべてのデバイスの`is_energized`フラグを`False`にリセットする。

2.  **走査の開始点:**
    *   グリッドの左端にあるすべての`L_SIDE`（電源バス）を探す。これらが電力の供給源であり、常に`is_energized = True`となる。ここが走査のスタート地点になる。

3.  **深さ優先探索 (DFS) による通電トレース:**
    *   各`L_SIDE`から、接続されている右隣のデバイスに向かって、再帰的に通電をトレースする。
    *   **トレース関数 `trace_power(device)` の処理概要:**
        a.  現在の`device`を「訪問済み」としてマークする（自己保持回路のようなループでの無限再帰を防ぐため）。
        b.  現在の`device`の`is_energized`を`True`にする。
        c.  現在の`device`のロジックを評価し、通電が継続するか判断する。
            *   **開いた接点** (`CONTACT_A`で`state`が`False`など) に到達した場合、そこで通電はストップする。
            *   **コイル** (`COIL`) に到達した場合、そのコイルの`state`を`True`に更新する。
            *   **配線や閉じた接点**の場合、通電は継続する。
        d.  通電が継続する場合、`device.connections`をたどり、まだ「訪問済み」でない隣接デバイスに対して、再帰的に`trace_power()`を呼び出す。

4.  **結果の反映:**
    *   このトレース処理が完了すると、`L_SIDE`から電気的に到達可能なすべてのデバイスの`is_energized`フラグが`True`になる。
    *   描画処理では、この`is_energized`フラグを参照して、通電している配線やデバイスの色を変化させる。

## 3. 補足：PLCの基本原則（最重要）

### アドレスが唯一の真実
PLCの世界では、デバイスの**「アドレス」**（`X001`, `Y001`, `M1`など）が、そのデバイスの状態を管理する**唯一のID**です。グリッド上のどこに配置されていようと、`X001`というアドレスを持つデバイスは、プログラム全体で**ただ一つの実体**として扱われます。

### コイルと接点の役割分担

この原則に基づき、2つの基本要素は明確に役割が分かれています。

*   **コイル (`-( )-)` の役割：状態を「書き込む」**
    *   コイルは、その行の論理演算の**「結果」**として、特定のアドレスの状態をON/OFFに**書き込む**ためのデバイスです。
    *   **ルール:** プログラム全体で、同じアドレスを持つ**標準コイルは1つしか配置できません**（二重コイルエラー）。

*   **接点 (`-| |-, -|/|-)` の役割：状態を「読み出す」**
    *   接点は、特定のアドレスの現在の状態を**「読み出し」**、その行の**「入力条件」**として使用するためのデバイスです。
    *   **ルール:** 同じアドレスの接点は、プログラム内に**何個でも配置できます**。

この「書き込み（コイル）」と「読み出し（接点）」の役割分担を理解することが、PLCシミュレーターを正しく実装する上での鍵となります。

## 4. 補足：PLCの論理スキャンと垂直リンクの概念

### PLCの動作原理

PLCは物理的な配線をそのままシミュレートするのではなく、ラダー図を**上から下へ、左から右へ**と順番に「解読」していくプログラムである。電力の「逆流」という概念はなく、「下の行の条件が成立したかを参照し、成立していれば上の行の分岐をONにする」と解釈するのが、PLCの動作に最も近い。

### 垂直リンクの命名と役割

この動作原理に基づき、垂直リンクの役割を明確にするため、以下の命名規則を採用する。

*   **`LINK_TO_UP`**: 下の行に配置される。**役割:** 上の行へ論理を送る**分岐点**となる。
    *   旧称: `LINK_DOWN`

*   **`LINK_FROM_DOWN`**: 上の行に配置される。**役割:** 下の行からの論理を受け取る**合流点**となる。
    *   旧称: `LINK_UP`

この命名により、電力（論理）の流れがコード上で直感的になり、解析アルゴリズムの実装が容易になる。

## 結論

このアーキテクチャにより、複雑な自己保持回路や並列回路であっても、その接続状態と通電状態を正確にシミュレートすることが可能になる。

---

## 開発ログ

### 2025-08-02: グリッド描画とデバイス配置機能の実装

#### 目的
デバイスパレットで選択したデバイスを、グリッド上にスプライトとして描画し、ユーザー入力に応じて配置・削除・状態変更ができるようにする。

#### 実装内容
1.  **グリッド描画のスプライト化 (`core/grid_system.py`)**:
    -   `_draw_devices` メソッドを修正し、`pyxel.rect`による仮描画から、`SpriteManager`を利用したスプライト描画 (`pyxel.blt`) に変更した。
    -   デバイスの `is_energized` 状態に応じて、ON/OFFのスプライトが切り替わるようにした。
    -   背景のグリッド線は、視認性確保のために維持することにした。

2.  **デバイスパレット描画の改善と差し戻し (`core/device_palette.py`)**:
    -   一度、パレットの表示をスプライトアイコンに置き換えたが、「アイコンだけでは分かりにくい」とのフィードバックを受け、元の文字ベースの表示に差し戻した。
    -   今後の改善案として「アイコン＋ホバーで詳細表示」方式を検討する。

3.  **デバイス配置・操作ロジックの確認 (`main.py`)**:
    -   `_handle_device_placement` メソッドに、デバイスの配置 (`place_device`)、削除 (`remove_device`)、状態変更 (`device.state`のトグル) のロジックが実装済みであることを確認した。
    -   これらの操作が、`update`ループ内で `circuit_analyzer.solve_ladder()` と連携し、データと描画の両方に即時反映されることを確認した。

#### 現状
-   デバイスパレットで選択したデバイスを、グリッド上にスプライトとして配置・削除できる。
-   右クリックでデバイスの内部状態 (`state`) を変更できる。
-   回路の通電状態 (`is_energized`) がスプライトのON/OFF表示に反映される。
-   基本的なデバイス操作と描画のサイクルが完成し、良好に動作している。

### 2025-08-02: スプライトキャッシュ機能の実装 (`core/SpriteManager.py`)

#### 目的
`sprites.json` に定義されたスプライト情報をアプリケーション起動時に読み込み、描画処理から効率的に利用するためのキャッシュ機構を構築する。

#### 実装内容
1.  **`sprites.json` の更新**:
    -   描画に必要なデバイス（各種リンクのON/OFF状態など）の定義を追加・修正した。

2.  **`core/SpriteManager.py` の新規作成**:
    -   `sprites.json` を読み込み、スプライト情報を内部にキャッシュする `SpriteManager` クラスを作成した。
    -   `get_sprite_coords(device_type, is_energized)` メソッドを実装し、デバイスの種類と状態から対応するスプライト座標を返却する機能を提供した。
    -   グローバルインスタンス `sprite_manager` を生成し、他モジュールからのアクセスを容易にした。

3.  **`main.py` への統合**:
    -   `sprite_manager` をインポートし、起動時に `pyxel.load()` でリソースファイルを読み込むように修正した。
    -   `SpriteManager` の動作を視覚的に確認するため、一時的なテスト描画コードを追加し、実行確認後に削除した。

#### 発生したトラブルと解決策
-   **`ModuleNotFoundError`**: `main.py` でのインポート文 (`core.sprite_manager`) と実際のファイル名 (`SpriteManager.py`) の大文字・小文字が一致していなかったため発生。インポート文を `core.SpriteManager` に修正して解決。
-   **`SyntaxError`**: `SpriteManager.py` 内の `for` ループで、キーとバリューの区切り文字にカンマ `,` ではなくハイフン `-` を誤って使用していたため発生。正しい構文に修正して解決。
-   **テストコードの残留**: ファイル修正時に誤ってコードを追記してしまい、クラス定義が二重化してテストコードが残存した。ファイルを正しい内容で完全に上書きして解決。

#### 現状
スプライトキャッシュ機能は正常に動作しており、今後の描画処理で利用可能な状態にある。

### 2025-08-02 (core/device_palette.py レビュー)

#### 🚧 気になる点

1.  **マウス入力処理の欠如:**
    *   `DevicePalette` クラスの docstring には「マウス選択対応」と記載されているが、`update_input` メソッド内では `_handle_keyboard_input()` しか呼び出されておらず、マウス入力に関するロジックが実装されていない。これはドキュメントと実際のコードの不一致。
    *   `CLAUDE.md` の「入力処理設計」にも「マウス直接選択（行切り替え不要）」とあるため、この機能は実装されるべきもの。

2.  **モジュール構成の計画との不一致:**
    *   `CLAUDE.md` の「Ver3デバイスパレットシステム設計完了」セクションでは、モジュール構成として `core/device_palette.py` (状態管理・ロジック)、`core/palette_renderer.py` (描画専用)、`core/palette_input.py` (入力処理専用) との役割分担が計画されている。
    *   しかし、現在の `core/device_palette.py` は `update_input` (入力処理) と `draw` (描画処理) の両方を直接含んでおり、計画されているモジュール分割がまだ行われていない。
    *   このままでは、将来的に `palette_renderer.py` や `palette_input.py` を作成する際に、現在の `DevicePalette` クラスからこれらのロジックを切り出すリファクタリングが必要になる。

### 2025-08-03: 配線デバイスの名称統一と垂直配線(LINK_VIRT)の再導入

#### 目的
- 水平配線デバイスの名称を `LINK_SIDE` から `LINK_HORZ` へ統一し、コードベース全体の整合性を向上させる。
- 視覚的な結線の明確化のため、垂直配線デバイス `LINK_VIRT` を再導入する。

#### 作業内容
1.  **`LINK_SIDE` から `LINK_HORZ` への名称統一**: 
    -   `config.py`: `DeviceType` および `DEVICE_PALETTE_DEFINITIONS` 内の `LINK_SIDE` を `LINK_HORZ` に変更。
    -   `core/circuit_analyzer.py`: `_is_conductive` メソッド内の `DeviceType.LINK_SIDE` を `DeviceType.LINK_HORZ` に変更。
    -   `sprites.json`: `NAME` が `LINK_SIDE` のスプライト定義を `LINK_HORZ` に変更（既に変更済みであったことを確認）。
    -   `New_Docs/DeviceSelectMenu.txt`: パレット定義の `LINK_SIDE` を `LINK_HORZ` に変更。
    -   `CLAUDE.md`, `_Ver3_Definition.md`: ドキュメント内の `LINK_SIDE` を `LINK_HORZ` に変更。

2.  **垂直配線デバイス `LINK_VIRT` の再導入**:
    -   **背景**: ユーザーからのフィードバックにより、一行空いた場合の結線が視覚的に分かりにくいという課題が提示されたため、明示的な垂直配線要素の必要性が再認識された。
    -   `config.py`: `DeviceType` に `LINK_VIRT` を追加し、`DEVICE_PALETTE_DEFINITIONS` の `top_row` (キーバインド8番) に `LINK_VIRT` を割り当て。
    -   `core/circuit_analyzer.py`: `_is_conductive` メソッドに `DeviceType.LINK_VIRT` を追加し、導通可能とする。
    -   `sprites.json`: 既存の `LINE_VIRT` の `NAME` を `LINK_VIRT` に変更。
    -   `New_Docs/DeviceSelectMenu.txt`: `LINK_VIRTICAL` の記述を `LINK_VIRT` に変更し、コメントを整理。
    -   `_Ver3_Definition.md`: 垂直配線に関する記述を `LINK_VIRT` に合わせて更新。

#### 発生したトラブルと解決策
-   **`config.py` の置換エラー**: `DEVICE_PALETTE_DEFINITIONS` 内の `EMPTY` が複数存在するため、`replace` コマンドが失敗。より具体的な `old_string` を指定することで解決。
-   **`core/circuit_analyzer.py` の置換エラー**: `config.py` の変更が先行したため、`DeviceType.LINK_SIDE` が解決できずエラー。`config.py` の変更を反映した正しい `old_string` を指定して解決。
-   **`LINK_VIRT` スプライトの表示問題**: `LINK_VIRT` を選択しても `LINK_HORZ` のスプライトが表示される問題が発生。
    -   `core/SpriteManager.py` にデバッグログを追加し、`get_sprite_coords` が正しい座標を返していることを確認。
    -   原因は `my_resource.pyxres` 内のスプライトデータ自体が誤っていたことと判明。Pyxel Editor で `(56, 8)` と `(64, 8)` のスプライトを正しい縦線のものに修正することで解決。
    -   `core/SpriteManager.py` の `EMPTY` の `ACT_NAME` の不整合も修正。

#### 現状
-   水平配線デバイスの名称統一が完了し、コードベース全体で `LINK_HORZ` が使用されている。
-   垂直配線デバイス `LINK_VIRT` がシステムに導入され、パレットからの選択、グリッドへの配置、通電ロジック、スプライト表示が正しく機能するようになった。
-   これにより、複雑な回路における視覚的な結線がより明確になった。

#### 今後のプラン
1.  **並列回路合流ロジックの完成**: `core/circuit_analyzer.py` の `_trace_power_flow` メソッド内の `LINK_FROM_DOWN` の TODO 部分を実装し、並列回路の通電解析を正確に行えるようにする。
2.  **タイマー・カウンターの実装**: `config.py` に定義されている `TIMER` と `COUNTER` デバイスのロジックを実装する。
3.  **デバイスパレットのマウス選択機能の強化**: `core/device_palette.py` のマウス入力処理を実装し、ユーザーがマウスで直接パレット上のデバイスを選択できるようにする。
4.  **デバッグ・検証機能の強化**: 回路の状態やデバイスのプロパティをリアルタイムで確認できるようなデバッグ機能を追加する。
5.  **UI/UXの改善**: デバイス表示の改善やステータス表示の拡張など、全体的なユーザーインターフェースとユーザーエクスペリエンスの向上を図る。
